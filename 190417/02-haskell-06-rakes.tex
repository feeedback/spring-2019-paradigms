\subsection{Грабли и плюшки}

\begin{frame}
	\tableofcontents[currentsection,currentsubsection]
\end{frame}

\begin{frame}[fragile]{Классы типов}
	\begin{itemize}
		\item Иногда хочется функцию полиморфную, но с ограничением на тип.
		\item Например, \t{min} должен уметь сравнивать свои аргументы.
		\item Набор свойств, которыми должен обладать тип, называют \textit{классом типа}.
		\item Подробнее разберём на следующем занятии.
		\item То, что идёт перед \t{=>} в типе в Haskell "--- это как раз ограничения на классы:
\begin{minted}{haskell}
min :: Ord a => a -> a -> a
\end{minted}
		\item \t{a} "--- любой тип, лежащий в классе \t{Ord}.
		\item Не путать с классами из ООП!
		\item Тут <<класс>> означает <<множество>>, как в математике.
	\end{itemize}
\end{frame}

\begin{frame}{Очень строгая типизация}
	% 08-01-types.hs
	\begin{itemize}
		\item Есть разные типы для вещественных и целых чисел.
		\item Оператор \t{==} между разными типами чисел не определён.
		\item Но тестом \t{2 == 2.0} это не поймать.
		\item Тип числовой константы определяется в момент компиляции: это будет либо вещественное число (класс \t{Fractional}), либо целое (класс \t{Integral}), либо любое (класс \t{Num}).
		\item Для конвертации между \t{Fractional} и \t{Integral} можно использовать \t{fromIntegral} и \t{round}.
		\item Может быть полезно прописывать типы явно: \t{(2::Integer)}
	\end{itemize}
\end{frame}

\begin{frame}{Унарный минус}
	\begin{itemize}
		\item Единственный унарный оператор в Haskell.
		\item Захардкожен костылями.
		\item Ломает красоту, потому что \t{(-3)} надо интерпретировать как унарный минус, а не как оператор \t{-} с зафиксированным операндом.
		\item А \t{((-)3)} надо интерпретировать, как оператор \t{(-)} с зафиксированным первым (левым) операндом.
		\item Поэтому зафиксировать правый аргумент у бинарного минуса никак нельзя, кроме лямбда-функций.
	\end{itemize}
\end{frame}
